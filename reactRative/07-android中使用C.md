---
title: android中调用c库
date: 2018-10-12
categories: react-native
---

# 环境配置

- 下载一个ndk，放到某个目录。配置ndk的环境变量，配置方法同jdk，可自行百度。

- 当环境都搭建好之后，在android项目中导入ndk：
  File -->Project Structure --> SDK Location 在Android NDK location中选择ndk的路径。

- 项目配置
  + 在local.properties文件中检查是否存在: `ndk.dir=D\:\\environment\\android\\android-ndk-r13b`
  + 在gradle.properties文件中添加： `android.useDeprecatedNdk=true`
  + 在app下的build.gradle文件中添加以下代码：

```json
android {
	//......
	defaultConfig {
      //......
      ndk {
		abiFilters "armeabi-v7a", "x86"
      }
	}
	sourceSets {
      main {
        jniLibs.srcDirs = ['src/main/libs']
      }
	}
	//......
}
```

# 生成so文件

其实C语言的程序员可以帮我们实现.so文件的编译，但是对于Android来说，要适配不同的CPU架构，需要多个so文件，所以so文件还是自己来生成。

##  生成头文件
创建一个java类:

```java
package com.blehealthme;

public class MyJin {
    static {
    //加载so库
        System.loadLibrary("Test");
    }
	//定义C中需要传递给java的接口，使用native关键字
	// 我们需要知道C中需要接收的参数个数及类型和返回的数据类型
    public native static int[][] calculateHeartRate(byte[] data, int len);
}
```

创建MyJni类后，首先执行build-->make project，目的是为了产生MyJni.class文件，然后需要依赖该类创建用于连接C和java头文件。

**生成头文件:**

- 首先在main文件夹下新建一个jni文件夹。
- 打开命令行，进入当前项目的java文件下，即android/app/src/main/java
- 执行 `javah -d ../jni com.blehealthme.MyJni` 命令，会在jni文件夹中看到一个新生成的.h文件，如com_blehealthme_MyJni.h，内容如下：

```C
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_blehealthme_MyJin */

#ifndef _Included_com_blehealthme_MyJin
#define _Included_com_blehealthme_MyJin
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_blehealthme_MyJin
 * Method:    calculateHeartRate
 * Signature: ([BI)[[I
 */
  // 此处相当于定义了一个接口，明确了返回值类型，参数的数量及类型
JNIEXPORT jobjectArray JNICALL Java_com_blehealthme_MyJin_calculateHeartRate
  (JNIEnv *, jclass, jbyteArray, jint);

#ifdef __cplusplus
}
#endif
#endif

```

生成头文件后需要新建Android.mk和Application.mk文件：

Android.mk:

```mk
LOCAL_PATH := $(call my-dir)    //固定写
include $(CLEAR_VARS)　　　　　　//固定写
LOCAL_MODULE    := Test　　　　//生成的so名称
LOCAL_SRC_FILES := test.c     // 用来生成so的C文件
include $(BUILD_SHARED_LIBRARY  //生成动态库
```

Application.mk 

```
APP_ABI := all //也可以写其他格式
```

## 生成so

一般来说，C文件不需要自己写，我们拿到了C的源码，经过修改即可。
在C文件中添加导出函数，里面的具体功能可以求助c的小伙伴来实现。
```c
JNIEXPORT jobjectArray JNICALL Java_com_blehealthme_MyJin_calculateHeartRate
        (JNIEnv *env, jclass jls, jbyteArray byteArr, jint length) {
	//.......
}
```
 最后，在android/app/src/main下打开命令行，指定`ndk-build`命令，即可生成一系列的so文件。

# 其他问题

```c
JNIEXPORT jobjectArray JNICALL Java_com_blehealthme_MyJin_calculateHeartRate
        (JNIEnv *env, jclass jls, jbyteArray byteArr, jint length) {
    //-------转换格式: java的byte[]转成c的char数组------------
    unsigned char array[1200];
    (*env)->GetByteArrayRegion(env, byteArr, 0, length, array);
    //------------------
    
    // 一下是将c的二维char数组，转成jobjectArray
    jobjectArray ret;
    int i = 0;
    int j = 0;
    int x= 10;
    int y = 10;

    jclass intArrCls = (*env)->FindClass(env, "[I");
    if ( NULL== intArrCls)
        return NULL;

    ret = (*env)->NewObjectArray(env, x * y, intArrCls, NULL);

    jint tmp[1024];//固定数组，测试用,注意别溢出
    for (i = 0; i < x; i++) {
        jintArray intArr = (*env)->NewIntArray(env,y);

        for (j = 0; j < y; j++) {
            tmp[j] = loc[j];
        }

        (*env)->SetIntArrayRegion(env,intArr, 0, y, tmp);
        (*env)->SetObjectArrayElement(env,ret, i, intArr);
        (*env)->DeleteLocalRef(env,intArr);
    }
    return ret;
}
```