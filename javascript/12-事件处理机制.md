---
title: 事件处理机制
date: 2016-05-07
categories: OOP
---

# 事件处理机制

* JavaScript是单线程的
* 浏览器本身是多线程的
  * 页面标签的渲染
  * 网络通信
  * 解析js运行
## 事件队列（任务队列）
* JavaScript的单线程决定了事件的执行需要排队，前一个任务执行完毕，才会执行后一个任务
* 能够进事件队列的函数
  * 定时函数(setTimeout,setInterval)
  * 事件函数
  * ajax的回调函数，即onreadystatechange指向的函数
```javascript
console.log(111);
for(var i=0;i<3;i++){
//遇到setTimeout会先将要执行的函数放进事件队列中，继续执行主线程，当主线程执行完毕后，才执行事件队列中的函数,因此，定时器中的函数只能在最后执行
  setTimeout(function(){
    console.log(i);
  },0);//0 代表按照浏览器的默认最小延时执行代码
}
console.log(222);
//以下为输出结果
//111
//222
//3
//3
//3
```
## 事件轮询(Event Loop)
* 主线程会循环不断的从事件队列中读取事件
* 当读取到事件时，会首先判断主线程是否空闲，再判断当前函数的执行条件是否满足，如果上述两个要求均满足，则执行事件
* setTimeout只是将事件放入了事件队列，必须等到主线程空闲才会去执行。因此，定时函数不一定会在执行的时间内执行
## 事件绑定
* 行内绑定
* 绑定到DOM元素上
* addEventListener / attachEvent
  * addEventListener("事件名"，“事件处理函数”，false);设置为false为允许冒泡
### 阻止冒泡和阻止默认行为
* 阻止冒泡：event.stopPropagation() / event.cancelBubble = true(兼容IE)
* 阻止默认行为：event.preventDefault() / event.returnValue = false(兼容IE)或者return false(不能阻止使用 addEventListener 绑定的事件)
* 在jQuery中，return false既可以阻止冒泡，又可以阻止默认行为
```html
<a href="www.baidu.com" id="jump">跳转</a>
<script>
var a = document.getElementById("jump");
a.addEventListener("click",function(){
	//此处不能阻止默认行为
	return false;
});
a.onclick = function(){
//此处可以阻止默认行为
  return false;
}
</script>
```
## 事件委托
* 将子元素的事件委托到父元素中处理
* jQuery中的on和delegate可是实现事件委托，原理如下
```html
<ul id="target"> 
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
    <li>item 4</li>
    <li>item 5</li>
    <li>item 6</li>
</ul>
<script>
onload = function(){
//使用该方法需要给多个元素绑定事件，消耗内存
	/*var lis = document.getElementsByTagName("li");
    for(var i=0;i<lis.length;i++){
        lis[i].onclick = function(){
            console.log(this.innerHTML);
        }
    }*/
//使用事件委托只需要给父元素绑定事件即可
    var ul = document.getElementById("target");
    ul.onclick = function(event){
        event = event||window.event;
        var target = event.target||event.srcElement;
        console.log(target.innerHTML);
    }
}
</script>
```
## 自定义事件
```javascript
function addEvent(obj,type,fn){
    obj.listener = obj.listener||{};
    obj.listener[type] = obj.listener[type]||[];
    obj.listener[type].push(fn);
}
function fireEvent(obj,type){
    var arr = obj.listener[type];
    for(var i=0;i<arr.length;i++){
        arr[i]();
    }
}
var obj = {};
addEvent(obj,"aaa",function(){console.log(111)});
addEvent(obj,"bbb",function(){console.log(222)});
addEvent(obj,"ccc",function(){console.log(333)});
addEvent(obj,"ddd",function(){console.log(444)});
fireEvent(obj,"aaa");
/*
//自定义事件的数据结构
obj.listener = {};
//属性作为事件名称，数组为放置事件函数的列表
obj.listener.aaa = [function(){}];
*/
```
